// main.c (ESP-IDF)
// ESP32-WROOM-32E:
// - PWM frequency on GPIO15
// - ADC voltage on GPIO34 (ADC1_CH6) and GPIO33 (ADC1_CH5)
// - MAX31865 on SPI: CS=GPIO26, MISO=GPIO19, MOSI=GPIO23, SCLK=GPIO18
//PID,Conversion de tension en deg C, safety, conversion avec le triac
// Notes:
// - MAX31865 is an RTD interface (PT100/PT1000), not a thermocouple IC.
// - ADC conversion uses ESP-IDF ADC calibration when available.
// - PWM frequency is measured by counting rising edges for 1 second using PCNT.

#include <stdio.h>
#include <string.h>
#include <math.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "driver/gpio.h"
#include "driver/pcnt.h"
#include "driver/spi_master.h"
#include "esp_err.h"
#include "esp_log.h"

#include "driver/adc.h"
#include "esp_adc_cal.h"

// ===================== User configuration =====================

/*#define ZC_PIN GPIO_NUM_4

gpio_config_t io_conf = {};
io_conf.intr_type = GPIO_INTR_POSEDGE;   // ou NEGEDGE selon ton montage
io_conf.mode = GPIO_MODE_INPUT;
io_conf.pin_bit_mask = (1ULL << ZC_PIN);
io_conf.pull_up_en = GPIO_PULLUP_ENABLE;

gpio_config(&io_conf);

// ISR service
gpio_install_isr_service(ESP_INTR_FLAG_IRAM);
gpio_isr_handler_add(ZC_PIN, zero_cross_isr, NULL);*/



#define PULSE_IN_GPIO         16 //ZCO

//#define PWM_IN_GPIO           15
#define PWM_IN_GPIO           2

#define ADC_GPIO_34           34  // ADC1_CH6
#define ADC_GPIO_33           33  // /DC1_CH5
#define ADC_CH_34             ADC1_CHANNEL_6
#define ADC_CH_33             ADC1_CHANNEL_5
#define ADC_ATTEN             ADC_ATTEN_DB_11   // ~0-3.3V range (approx)
#define ADC_WIDTH             ADC_WIDTH_BIT_12

// SPI (MAX31865)
#define MAX31865_CS_GPIO      26
//define MAX31865_CS_GPIO      13
//#define MAX31865_CS_GPIO      12
#define MAX31865_MISO_GPIO    19
#define MAX31865_MOSI_GPIO    23
#define MAX31865_SCLK_GPIO    18

// MAX31865 settings
#define MAX31865_RREF_OHMS    430.0f   // Common reference resistor value (adjust to your board)
#define MAX31865_R0_OHMS      100.0f   // PT100 = 100Ω, PT1000 = 1000Ω
#define MAX31865_3WIRE        1        // set 1 if you use 3-wire RTD

// ===================== PWM frequency via PCNT =====================
static esp_err_t pwm_freq_init_pcnt(void)
{
    // PCNT counts pulses on rising edges
    pcnt_config_t pcnt_config = {
        .pulse_gpio_num = PWM_IN_GPIO,
        .ctrl_gpio_num = PCNT_PIN_NOT_USED,
        .channel = PCNT_CHANNEL_0,
        .unit = PCNT_UNIT_0,

        // Count on positive edge, ignore negative edge
        .pos_mode = PCNT_COUNT_INC,
        .neg_mode = PCNT_COUNT_DIS,

        .lctrl_mode = PCNT_MODE_KEEP,
        .hctrl_mode = PCNT_MODE_KEEP,

        .counter_h_lim = 32767,
        .counter_l_lim = 0,
    };

    ESP_ERROR_CHECK(pcnt_unit_config(&pcnt_config));

    // Optional: simple glitch filter (in APB clock cycles). Tune if needed.
    // Filter value example: 100 => rejects very short spikes.
    ESP_ERROR_CHECK(pcnt_set_filter_value(PCNT_UNIT_0, 100));
    ESP_ERROR_CHECK(pcnt_filter_enable(PCNT_UNIT_0));

    ESP_ERROR_CHECK(pcnt_counter_pause(PCNT_UNIT_0));
    ESP_ERROR_CHECK(pcnt_counter_clear(PCNT_UNIT_0));
    ESP_ERROR_CHECK(pcnt_counter_resume(PCNT_UNIT_0));

    return ESP_OK;
}

static esp_err_t pulse_count_init_pcnt(void)
{
    pcnt_config_t pcnt_config = {
        .pulse_gpio_num = PULSE_IN_GPIO,
        .ctrl_gpio_num = PCNT_PIN_NOT_USED,
        .channel = PCNT_CHANNEL_0,
        .unit = PCNT_UNIT_1,

        .pos_mode = PCNT_COUNT_INC,
        .neg_mode = PCNT_COUNT_DIS,

        .lctrl_mode = PCNT_MODE_KEEP,
        .hctrl_mode = PCNT_MODE_KEEP,

        .counter_h_lim = 32767,
        .counter_l_lim = 0,
    };

    ESP_ERROR_CHECK(pcnt_unit_config(&pcnt_config));

    ESP_ERROR_CHECK(pcnt_set_filter_value(PCNT_UNIT_1, 100));
    ESP_ERROR_CHECK(pcnt_filter_enable(PCNT_UNIT_1));

    ESP_ERROR_CHECK(pcnt_counter_pause(PCNT_UNIT_1));
    ESP_ERROR_CHECK(pcnt_counter_clear(PCNT_UNIT_1));
    ESP_ERROR_CHECK(pcnt_counter_resume(PCNT_UNIT_1));

    return ESP_OK;
}

// static float pwm_measure_frequency_hz_1s_gate(void)
// {
//     int16_t count = 0;
//     pcnt_counter_clear(PCNT_UNIT_0);

//     // Gate time = 1 second
//     vTaskDelay(pdMS_TO_TICKS(1000));

//     pcnt_get_counter_value(PCNT_UNIT_0, &count);

//     // If the input is a 50% duty PWM, counting rising edges gives frequency directly.
//     // (If you count both edges, you would divide by 2.)
//     return (float)count;
// }

static void measure_pcnt_1s_gate(float *pwm_freq_hz_out, int16_t *gpio16_pulses_out)
{
    int16_t pwm_count = 0;
    int16_t pulse16_count = 0;

    pcnt_counter_clear(PCNT_UNIT_0); // PWM_IN_GPIO
    pcnt_counter_clear(PCNT_UNIT_1); // GPIO16 pulses

    // Gate time = 1 second
    vTaskDelay(pdMS_TO_TICKS(1000));

    pcnt_get_counter_value(PCNT_UNIT_0, &pwm_count);
    pcnt_get_counter_value(PCNT_UNIT_1, &pulse16_count);

    *pwm_freq_hz_out = (float)pwm_count;     // rising edges per second = Hz
    *gpio16_pulses_out = pulse16_count;      // pulses counted in 1 second
}


// ===================== ADC voltage =====================
static esp_adc_cal_characteristics_t adc_chars;
static bool adc_cal_ok = false;

static void adc_init(void)
{
    adc1_config_width(ADC_WIDTH);
    adc1_config_channel_atten(ADC_CH_34, ADC_ATTEN);
    adc1_config_channel_atten(ADC_CH_33, ADC_ATTEN);

    // ADC calibration (legacy API; works well on ESP32 + ESP-IDF)
    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(
        ADC_UNIT_1,
        ADC_ATTEN,
        ADC_WIDTH,
        1100,          // default Vref in mV if eFuse not available
        &adc_chars
    );

    adc_cal_ok = (val_type != ESP_ADC_CAL_VAL_DEFAULT_VREF);
}

static float adc_read_voltage(adc1_channel_t ch)
{
    int raw = adc1_get_raw(ch);
    uint32_t mv = esp_adc_cal_raw_to_voltage(raw, &adc_chars);
    return (float)mv / 1000.0f;
}

// ===================== MAX31865 (SPI) =====================
// MAX31865 registers
#define MAX31865_REG_CONFIG   0x00
#define MAX31865_REG_RTD_MSB  0x01
#define MAX31865_REG_RTD_LSB  0x02

// Config bits
#define MAX31865_CFG_BIAS     (1 << 7)
#define MAX31865_CFG_MODEAUTO (1 << 6)
#define MAX31865_CFG_1SHOT    (1 << 5)
#define MAX31865_CFG_3WIRE    (1 << 4)
#define MAX31865_CFG_FAULTCLR (1 << 1)
#define MAX31865_CFG_FILT50HZ (1 << 0) // 0=60Hz, 1=50Hz

static spi_device_handle_t max31865_dev = NULL;

static esp_err_t max31865_write_reg(uint8_t reg, uint8_t val)
{
    // Write: set MSB of address
    uint8_t tx[2] = { (uint8_t)(reg | 0x80), val };

    spi_transaction_t t;
    memset(&t, 0, sizeof(t));
    t.length = 8 * sizeof(tx);
    t.tx_buffer = tx;

    return spi_device_transmit(max31865_dev, &t);
}

static esp_err_t max31865_read_regs(uint8_t start_reg, uint8_t *out, size_t len)
{
    // Single transaction: [addr][dummy...]
    // while receiving: [junk][data...]
    uint8_t tx[1 + len];
    uint8_t rx[1 + len];
    memset(tx, 0, sizeof(tx));
    memset(rx, 0, sizeof(rx));

    tx[0] = (uint8_t)(start_reg & 0x7F);

    spi_transaction_t t;
    memset(&t, 0, sizeof(t));
    t.length = 8 * (1 + len);
    t.tx_buffer = tx;
    t.rx_buffer = rx;

    esp_err_t err = spi_device_transmit(max31865_dev, &t);
    if (err != ESP_OK) return err;

    memcpy(out, &rx[1], len); // skip first garbage byte
    return ESP_OK;
}

static uint8_t max31865_read_reg(uint8_t reg)
{
    uint8_t tx[2] = { reg & 0x7F, 0x00 };
    uint8_t rx[2] = {0};

    spi_transaction_t t = {0};
    t.length = 16;
    t.tx_buffer = tx;
    t.rx_buffer = rx;

    spi_device_transmit(max31865_dev, &t);

    return rx[1];  // second byte is the register data
}

static esp_err_t max31865_init_spi(void)
{
    spi_bus_config_t buscfg = {
        .mosi_io_num = MAX31865_MOSI_GPIO,
        .miso_io_num = MAX31865_MISO_GPIO,
        .sclk_io_num = MAX31865_SCLK_GPIO,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = 0,
    };

    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 1 * 1000 * 1000,  // 1 MHz is safe for MAX31865
        .mode = 1,                          // MAX31865 uses SPI mode 1
        .spics_io_num = MAX31865_CS_GPIO,
        .queue_size = 1,
    };

    ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO));
    ESP_ERROR_CHECK(spi_bus_add_device(SPI2_HOST, &devcfg, &max31865_dev));

    // Configure MAX31865: bias OFF initially, manual mode, clear faults, 3-wire optional, 60Hz filter by default
    uint8_t cfg = 0;
    cfg |= MAX31865_CFG_FAULTCLR;
    if (MAX31865_3WIRE) cfg |= MAX31865_CFG_3WIRE;
    // cfg |= MAX31865_CFG_FILT50HZ; // enable if your mains interference is 50Hz
    ESP_ERROR_CHECK(max31865_write_reg(MAX31865_REG_CONFIG, cfg));

    return ESP_OK;
}

static void max31865_dump_regs(void)
{
    uint8_t r[8] = {0};
    max31865_read_regs(0x00, r, sizeof(r));

    printf("MAX31865 regs: "
           "CFG=0x%02X RTD_MSB=0x%02X RTD_LSB=0x%02X "
           "HIGH_FT_MSB=0x%02X HIGH_FT_LSB=0x%02X "
           "LOW_FT_MSB=0x%02X LOW_FT_LSB=0x%02X "
           "FAULT=0x%02X\n",
           r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7]);
}

static void max31865_set_thresholds_pt100(void)
{
    // Low threshold: ~ -50C
    max31865_write_reg(0x05, 0x05); // LFT MSB (0x05)
    max31865_write_reg(0x06, 0x1E); // LFT LSB (0x1E)

    // High threshold: ~ 250C
    max31865_write_reg(0x03, 0x0C); // HFT MSB (0x0C)
    max31865_write_reg(0x04, 0x5C); // HFT LSB (0x5C)
}

static float rtd_resistance_from_code(uint16_t rtd_code)
{
    // rtd_code is the 15-bit value (fault bit removed), range 0..32767
    // From datasheet: RTD resistance = (code / 32768) * Rref
    return ((float)rtd_code * MAX31865_RREF_OHMS) / 32768.0f;
}

// Callendar–Van Dusen (for platinum RTDs) coefficients for 0..850°C
static float rtd_temp_c_from_resistance(float Rt)
{
    // For T >= 0: Rt = R0 (1 + A T + B T^2)
    // Solve quadratic for T.
    const float R0 = MAX31865_R0_OHMS;
    const float A = 3.9083e-3f;
    const float B = -5.775e-7f;

    // Rt/R0 = 1 + A T + B T^2  =>  B T^2 + A T + (1 - Rt/R0) = 0
    float c = 1.0f - (Rt / R0);
    float disc = A * A - 4.0f * B * c;
    if (disc < 0) return NAN;

    float T = (-A + sqrtf(disc)) / (2.0f * B);

    // This formula works well for >= 0°C. For <0°C, you need the full CVD with C term.
    // We’ll provide a basic fallback for negative temps using a simple approximation:
    if (T < 0.0f) {
        // Rough approximation for negative temps (still usable for many projects).
        // If you need accurate negative temps, tell me your RTD type and range.
        T = (Rt - R0) / (R0 * A);
    }
    return T;
}

static esp_err_t max31865_read_temperature_c(float *temp_c_out)
{
    // 1) Enable bias
    uint8_t cfg = 0;
    cfg |= MAX31865_CFG_BIAS;
    if (MAX31865_3WIRE) cfg |= MAX31865_CFG_3WIRE;
    cfg |= MAX31865_CFG_FAULTCLR;
    ESP_ERROR_CHECK(max31865_write_reg(MAX31865_REG_CONFIG, cfg));

    // Bias settle time (datasheet typical ~10ms)
    vTaskDelay(pdMS_TO_TICKS(10));

    // 2) Start one-shot conversion
    cfg |= MAX31865_CFG_1SHOT;
    ESP_ERROR_CHECK(max31865_write_reg(MAX31865_REG_CONFIG, cfg));

    // Conversion time depends on filter:
    // 60Hz: ~55ms, 50Hz: ~65ms (typical). Wait 70ms to be safe.
    vTaskDelay(pdMS_TO_TICKS(70));

    // 3) Read RTD MSB/LSB
    uint8_t buf[2] = {0};
    ESP_ERROR_CHECK(max31865_read_regs(MAX31865_REG_RTD_MSB, buf, 2));

    uint16_t rtd = ((uint16_t)buf[0] << 8) | buf[1];

    // LSB bit0 is fault flag; 15-bit RTD code is bits[15:1]
    uint16_t rtd_code = (rtd >> 1) & 0x7FFF;

    // 4) Disable bias to reduce self-heating
    uint8_t cfg_off = 0;
    cfg_off |= MAX31865_CFG_FAULTCLR;
    if (MAX31865_3WIRE) cfg_off |= MAX31865_CFG_3WIRE;
    ESP_ERROR_CHECK(max31865_write_reg(MAX31865_REG_CONFIG, cfg_off));

    float Rt = rtd_resistance_from_code(rtd_code);
    float Tc = rtd_temp_c_from_resistance(Rt);

    *temp_c_out = Tc;
    return ESP_OK;
}

// ===================== Main task =====================
void app_main(void)
{
    ESP_ERROR_CHECK(pwm_freq_init_pcnt());
    ESP_ERROR_CHECK(pulse_count_init_pcnt());
    adc_init();
    ESP_ERROR_CHECK(max31865_init_spi());
    max31865_set_thresholds_pt100();
    max31865_write_reg(0x00, 0xD0 | 0x02); // set fault clear bit;

    while (1) {
        float freq_hz = 0.0f;
        int16_t pulses_gpio16 = 0;
        measure_pcnt_1s_gate(&freq_hz, &pulses_gpio16);
    
        float v34 = adc_read_voltage(ADC_CH_34);
        float v33 = adc_read_voltage(ADC_CH_33);
    
        float temp_c = NAN;
        esp_err_t te = max31865_read_temperature_c(&temp_c);
    
        if (te == ESP_OK) {
            printf("PWM(GPIO%d): %.0f Hz | PULSE(GPIO16): %d /s | ADC(GPIO34): %.3f V | ADC(GPIO33): %.3f V | RTD(MAX31865): %.2f C\n",
                   PWM_IN_GPIO, freq_hz, pulses_gpio16, v34, v33, temp_c);
        } else {
            printf("PWM(GPIO%d): %.0f Hz | PULSE(GPIO16): %d /s | ADC(GPIO34): %.3f V | ADC(GPIO33): %.3f V | RTD(MAX31865): ERROR (%s)\n",
                   PWM_IN_GPIO, freq_hz, pulses_gpio16, v34, v33, esp_err_to_name(te));
        }
    
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}